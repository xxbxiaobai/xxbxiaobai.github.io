{"meta":{"title":"Manchi","subtitle":"","description":"","author":"Manchi","url":"https://corn0124.cn","root":"/"},"pages":[],"posts":[{"title":"猫猫和狗狗——ES6新增知识点","slug":"猫猫和狗狗——ES6新增知识点","date":"un11fin11","updated":"un22fin22","comments":true,"path":"2022/03/14/猫猫和狗狗——ES6新增知识点/","link":"","permalink":"https://corn0124.cn/2022/03/14/%E7%8C%AB%E7%8C%AB%E5%92%8C%E7%8B%97%E7%8B%97%E2%80%94%E2%80%94ES6%E6%96%B0%E5%A2%9E%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"本文就ES6新增知识点和语法糖做一个阶段性汇总更新，没有更新到的地方可能是我暂时没用到，也可能是我菜的用不着…… 数组新增方法new Set()1.什么是Set() Set是es6新增的数据结构，似于数组，但它的一大特性就是所有元素都是唯一的，没有重复的值，我们一般称为集合。 Set本身是一个构造函数，用来生成 Set 数据结构 2、增删改查方法 添加元素add 添加某个值，返回 Set 结构本身，当添加实例中已经存在的元素，set不会进行处理添加123let list=new Set();list.add(1)list.add(2).add(3).add(3) // 2只被添加了一次 删除元素delete 删除某个值，返回一个布尔值，表示删除是否成功12let list=new Set([1,20,30,40])list.delete(30) //删除值为30的元素，这里的30并非下标 判断某元素是否存在has 返回一个布尔值，判断该值是否为Set的成员12let list=new Set([1,2,3,4])list.has(2)//true 清除所有元素clear 清除所有成员，没有返回值12let list=new Set([1,2,3,4])list.clear() 3、遍历方法 遍历 keys() 返回键名的遍历器，相等于返回键值遍历器values()1234let list2=new Set([&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;])for(let key of list2.keys())&#123; console.log(key)//a,b,c&#125; 遍历 values() 返回键值的遍历器1234let list=new Set([&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;])for(let value of list.values())&#123;console.log(value)//a,b,c&#125; 遍历 entries() 返回键值对的遍历器12345let list=new Set([&#x27;4&#x27;,&#x27;5&#x27;,&#x27;hello&#x27;])for (let item of list.entries()) &#123; console.log(item);&#125;// [&#x27;4&#x27;,&#x27;4&#x27;] [&#x27;5&#x27;,&#x27;5&#x27;] [&#x27;hello&#x27;,&#x27;hello&#x27;] 遍历 forEach() 使用回调函数遍历每个成员123let list=new Set([&#x27;4&#x27;,&#x27;5&#x27;,&#x27;hello&#x27;])list.forEach((value, key) =&gt; console.log(key + &#x27; : &#x27; + value))// 4:4 5:5 hello:hello 4、使用情形 用于数组去重 12345678let arr = [3, 5, 2, 2, 5, 5];let setArr = new Set(arr) // 返回set数据结构 Set(3) &#123;3, 5, 2&#125;//方法一 es6的...解构let unique1 = [...setArr ]; //去重转数组后 [3,5,2]//方法二 Array.from()解析类数组为数组let unique2 = Array.from(setArr ) //去重转数组后 [3,5,2] 用于字符串去重 12let str = &quot;352255&quot;;let unique = [...new Set(str)].join(&quot;&quot;); // 352 实现并集、交集、和差集 1234567891011121314let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set &#123;2, 3&#125;// （a 相对于 b 的）差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// Set &#123;1&#125;","categories":[],"tags":[{"name":"猫狗日记","slug":"猫狗日记","permalink":"https://corn0124.cn/tags/%E7%8C%AB%E7%8B%97%E6%97%A5%E8%AE%B0/"}]},{"title":"带你一文了解Vue3","slug":"带你一文了解Vue3","date":"un55fin55","updated":"un55fin55","comments":true,"path":"2022/02/25/带你一文了解Vue3/","link":"","permalink":"https://corn0124.cn/2022/02/25/%E5%B8%A6%E4%BD%A0%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3Vue3/","excerpt":"","text":"相对于我们开发人员来说，Vue3并不陌生，已经习惯了Vue2开发的前端工程师们注意了，你所知道的Vue3它并不只是Vue一个版本的迭代升级，而是一个质的飞跃，具有划时代里程碑的意义。那我们就简单赘述下吧： Vue3与Vue2的区别1.vue2和vue3双向数据绑定原理发生了改变 vue2 的双向数据绑定是利用ES5 的一个 API Object.definePropert()对数据进行劫持 结合 发布订阅模式的方式来实现的 vue3 中使用了 es6 的 ProxyAPI 对数据代理优势如下： 1.defineProperty只能监听某个属性，不能对全对象监听 2.可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可） 3.可以监听数组，不用再去单独的对数组做特异性操作 vue3可以检测到数组内部数据的变化 vue3的组件实例代理 vue3对ref的特殊处理 2.vue3支持多节点（这个就不多说了，自行脑补）3.特有的composition api这个特性使得Vue3的代码更加统一整齐，也是这个特性让vue文件的编写习惯发生了翻天覆地的变化，看图吧 composition api option api 4.效率的飞升(开发阶段) 客户端渲染效率比vue2提升了1.3~2倍 SSR渲染效率比vue2提升了2~3倍 面试题：vue3的效率提升主要表现在哪些方面？ 静态提升下面的静态节点会被提升 元素节点 没有绑定动态内容 1234567891011// vue2 的静态节点render()&#123; createVNode(&quot;h1&quot;, null, &quot;Hello World&quot;) // ...&#125;// vue3 的静态节点const hoisted = createVNode(&quot;h1&quot;, null, &quot;Hello World&quot;)function render()&#123; // 直接使用 hoisted 即可&#125; 静态属性会被提升 123&lt;div class=&quot;user&quot;&gt; &#123;&#123;user.name&#125;&#125;&lt;/div&gt; 123456const hoisted = &#123; class: &quot;user&quot; &#125;function render()&#123; createVNode(&quot;div&quot;, hoisted, user.name) // ...&#125; 预字符串化123456789101112131415&lt;div class=&quot;menu-bar-container&quot;&gt; &lt;div class=&quot;logo&quot;&gt; &lt;h1&gt;logo&lt;/h1&gt; &lt;/div&gt; &lt;ul class=&quot;nav&quot;&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;menu&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;menu&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;menu&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;menu&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;menu&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;user&quot;&gt; &lt;span&gt;&#123;&#123; user.name &#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 当编译器遇到大量连续的静态内容，会直接将其编译为一个普通字符串节点 1const _hoisted_2 = _createStaticVNode(&quot;&lt;div class=\\&quot;logo\\&quot;&gt;&lt;h1&gt;logo&lt;/h1&gt;&lt;/div&gt;&lt;ul class=\\&quot;nav\\&quot;&gt;&lt;li&gt;&lt;a href=\\&quot;\\&quot;&gt;menu&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\\&quot;\\&quot;&gt;menu&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\\&quot;\\&quot;&gt;menu&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\\&quot;\\&quot;&gt;menu&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\\&quot;\\&quot;&gt;menu&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&quot;) 缓存事件处理函数1&lt;button @click=&quot;count++&quot;&gt;plus&lt;/button&gt; 123456789101112131415// vue2render(ctx)&#123; return createVNode(&quot;button&quot;, &#123; onClick: function($event)&#123; ctx.count++; &#125; &#125;)&#125;// vue3render(ctx, _cache)&#123; return createVNode(&quot;button&quot;, &#123; onClick: cache[0] || (cache[0] = ($event) =&gt; (ctx.count++)) &#125;)&#125; Block Treevue2在对比新旧树的时候，并不知道哪些节点是静态的，哪些是动态的，因此只能一层一层比较，这就浪费了大部分时间在比对静态节点上 12345678910&lt;form&gt; &lt;div&gt; &lt;label&gt;账号：&lt;/label&gt; &lt;input v-model=&quot;user.loginId&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input v-model=&quot;user.loginPwd&quot; /&gt; &lt;/div&gt;&lt;/form&gt; PatchFlagvue2在对比每一个节点时，并不知道这个节点哪些相关信息会发生变化，因此只能将所有信息依次比对 123&lt;div class=&quot;user&quot; data-id=&quot;1&quot; title=&quot;user name&quot;&gt; &#123;&#123;user.name&#125;&#125;&lt;/div&gt;","categories":[],"tags":[]},{"title":"原生文件上传","slug":"原生文件上传","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2022/02/21/原生文件上传/","link":"","permalink":"https://corn0124.cn/2022/02/21/%E5%8E%9F%E7%94%9F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","excerpt":"","text":"最近在移动端开发过程中上传文件时一直使用着uniapp中提供的uni.uploadFile api,但是最近发现这个api问题还是有点大的，实测发现这个api更倾向于移动端的图片上传，对ios的文件上传不是很兼容，Android还行，但是选择文件起来还是相对较麻烦，这不经让我对uniapp组件库产生了怀疑，于是我去搜罗其论坛，发现确实存在这个问题，那没办法了，既然官方不给提供更好的解决方案，那就只能自己重新写个了。大致如下： 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;template&gt; &lt;view&gt; &lt;view class=&quot;demo&quot; @click=&quot;inputClick()&quot;&gt;点我上传&lt;/view&gt; &lt;view ref=&quot;input&quot; class=&quot;inputFile&quot;&gt;&lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; &#125; &#125;, mounted() &#123; this.fileInit(&#x27;input&#x27;, &#x27;yt_file&#x27;, this.newUpLoad1) &#125;, methods: &#123; /* url 服务器上传路径如（https://gl.tyj.zj.gov.cn/api-file/foreign/files-anon）; fileObj 自己页面定义的input file，（例如 ： var fileObj = document.getElementById(&quot;file&quot;).files[0]）； paramArry 参数 （无传null, 有的话传入数组对象，例如： [&#123;name:1,id:1&#125;]这种形式）； func 成功返回； onprogress 当前进度条状态回调； error 失败回调 */ //xhr原生上传文件 xhrUpladFile(url, fileObj, paramArry, func, onprogress, error) &#123; var form = new FormData(); form.append(&quot;file&quot;, fileObj); if (paramArry != null) &#123; paramArry.forEach((item) =&gt; &#123; form.append(item.name, item.value) &#125;) &#125; var xhr = new XMLHttpRequest(); xhr.open(&quot;post&quot;, url, true); xhr.withCredentials = true; xhr.upload.onprogress = function(e) &#123; //上传开始执行方法 // console.log(&quot;已上传===&quot; + JSON.stringify(e.loaded)); // console.log(&quot;总大小===&quot; + JSON.stringify(e.total)); onprogress(e.loaded, e.total); &#125; xhr.onreadystatechange = function() &#123; switch (xhr.readyState) &#123; case 0: console.log(&quot;请求未初始化&quot;); break; case 1: console.log(&quot;请求启动，尚未发送&quot;); break; case 2: console.log(&quot;请求发送，尚未得到响应&quot;); break; case 3: console.log(&quot;请求开始响应，收到部分数据&quot;); break; case 4: if (xhr.status == 200) &#123; uni.hideLoading() var data = JSON.parse(xhr.responseText); // console.log(JSON.stringify(data)); func(data); &#125; break; &#125; &#125; xhr.onerror = function(err) &#123; //请求失败 console.log(&quot;上传失败！&quot;); error(err); &#125;; xhr.send(form); //开始上传，发送form数据 &#125;, //文件上传初始化 fileInit(refId, inputId, func) &#123; var input = document.createElement(&#x27;input&#x27;) input.type = &#x27;file&#x27; input.id = inputId input.onchange = (event) =&gt; &#123; this.xhrUpladFile(&#x27;https://gl.tyj.zj.gov.cn/api-file/foreign/files-anon&#x27;, event.target.files[0], null, func, this.status) &#125; this.$refs[refId].$el.appendChild(input) &#125;, newUpLoad1(data) &#123; //data为上传文件接口返回的响应数据 这里可以对其进行一些了骚操作 &#125;, status() &#123; uni.showLoading(&#123; title: &#x27;上传中&#x27;, mask:true &#125;) &#125;, inputClick() &#123;//通过其他容器来触发input原生的点击事件发起上传，原生input上传则被隐藏(改它的样式太难了，巨丑无比) document.querySelector(&#x27;#yt_file&#x27;).click() &#125;, &#125; &#125;&lt;/script&gt;&lt;style&gt; .demo&#123; width: 100rpx; height: 100rpx; background: #f40; &#125; .inputFile&#123; position: absolute; opacity: 0; top: -99999px; &#125;&lt;/style&gt;","categories":[],"tags":[]},{"title":"JS拖拽两种实现方式","slug":"JS拖拽两种实现方式","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2022/01/05/JS拖拽两种实现方式/","link":"","permalink":"https://corn0124.cn/2022/01/05/JS%E6%8B%96%E6%8B%BD%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/","excerpt":"","text":"拖拽最近整理了一下以前了解过的一些小demo，就从拖拽说起吧，用原生js实现拖拽效果，大致可分为两种，一是使用鼠标事件，(mousedown、mousemove和mouseup)，二是使用H5拖拽drag与拖放drop属性，下面逐一进行代码演示: 使用鼠标事件实现拖拽效果html 123&lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;&lt;/div&gt; css 123456789101112131415161718*&#123; margin: 0; padding: 0; border: 0; &#125; #container&#123; width: 500px; height: 500px; border: 1px solid #000; position: relative; &#125; #demo&#123; width: 100px; height: 100px; background-color: #f40; position: absolute; cursor: pointer; &#125; js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 初始化 var dragFun = function(child,parent)&#123; var drag = document.getElementById(child); var dragContainer = document.getElementById(parent) || document; // //点击某物体时，用drag对象即可，move和up是全局区域， // 也就是整个文档通用，应该使用document对象而不是drag对象(否则，采用drag对象时物体会出现拖拽丢失) drag.onmousedown = function(event)&#123; var event = event || window.event; //兼容IE浏览器 // 鼠标点击物体那一刻相对于物体左侧边框的距离=点击时的位置相对于浏览器最左边的距离-物体左边框相对于浏览器最左边的距离 var diffX = event.clientX - drag.offsetLeft; var diffY = event.clientY - drag.offsetTop; if(typeof drag.setCapture !== &#x27;undefined&#x27;)&#123; drag.setCapture(); //设置元素对鼠标事件的捕获 &#125; document.onmousemove = function(event)&#123; var event = event || window.event; var moveX = event.clientX - diffX; var moveY = event.clientY - diffY; if(moveX &lt; 0)&#123;//超出document区域适配,前提是不传父级元素的id moveX = 0 &#125;else if(moveX &gt; window.innerWidth - drag.offsetWidth)&#123; moveX = window.innerWidth - drag.offsetWidth &#125; if(moveY &lt; 0)&#123; moveY = 0 &#125;else if(moveY &gt; window.innerHeight - drag.offsetHeight)&#123; moveY = window.innerHeight - drag.offsetHeight &#125; if(moveX &lt; 0)&#123;//超出父级容器适配 moveX = 0 &#125;else if(moveX &gt; dragContainer.offsetWidth - drag.offsetWidth)&#123; moveX = dragContainer.offsetWidth - drag.offsetWidth &#125; if(moveY &lt; 0)&#123; moveY = 0 &#125;else if(moveY &gt; dragContainer.offsetHeight - drag.offsetHeight)&#123; moveY = dragContainer.offsetHeight - drag.offsetHeight &#125; drag.style.left = moveX + &#x27;px&#x27;; drag.style.top = moveY + &#x27;px&#x27; &#125; document.onmouseup = function(event)&#123; this.onmousemove = null; this.onmouseup = null; //修复低版本ie bug if(typeof drag.releaseCapture!=&#x27;undefined&#x27;)&#123; drag.releaseCapture(); //设置元素对鼠标事件的释放 &#125; &#125; &#125; &#125; dragFun(&#x27;demo&#x27;,&#x27;container&#x27;) 使用H5拖拽属性实现拖拽效果html 123&lt;div class=&quot;box1&quot; draggable=&quot;true&quot; id=&quot;source&quot;&gt;&lt;/div&gt; &lt;br&gt;&lt;div class=&quot;box2&quot; id=&quot;target&quot;&gt;&lt;/div&gt; css 123456789101112131415*&#123; margin: 0; padding: 0; border: 0; &#125; .box1 &#123; width: 100px; height: 100px; background: salmon &#125; .box2 &#123; width: 300px; height: 300px; border: 1px solid black &#125; js 123456789101112131415161718192021222324252627window.onload = function () &#123; var source = document.getElementById(&#x27;source&#x27;); var target = document.getElementById(&#x27;target&#x27;); source.ondragstart = function (event) &#123; var e = event || window.event console.log(&#x27;开始拖拽&#x27;); e.dataTransfer.setData(&#x27;text&#x27;, e.target.id); &#125; target.ondragenter = function () &#123; console.log(&#x27;进入目标元素&#x27;) &#125; target.ondragover = function (event) &#123; var event = event || window.event; console.log(&#x27;在目标元素中拖拽&#x27;); event.preventDefault() &#125; target.ondragleave = function () &#123; console.log(&#x27;拖放离开目标元素&#x27;) &#125; target.ondrop = function (event) &#123; console.log(&#x27;拖放&#x27;); var e = event || window.event var data = e.dataTransfer.getData(&#x27;text&#x27;); e.target.appendChild(document.getElementById(data)); &#125; &#125;","categories":[],"tags":[]},{"title":"数组列表与字符串按需转换","slug":"数组列表与字符串按需转换","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2021/12/08/数组列表与字符串按需转换/","link":"","permalink":"https://corn0124.cn/2021/12/08/%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8C%89%E9%9C%80%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"需求:实现列表到字符串的相互转换具体如下:1:列表到字符串,您需要将输入列表转换为字符串。这输入列表只能包含两种类型的项目:单个字母(即A-Z和 a-z，区分大小写)或其他具有相同属性的列表。输出应以如下方式构造字符串:以方括号开头和结尾(即[])。列表中的字母项简单地连接到细绳。子列表的内容应放在方括号之间。完整的函数list2str(1)，它将满足的列表作为输入上面的属性并提供一个字符串作为输出，如上所述。例子:1)list2str([‘a’,[‘bc’]]) 应该返回’[a[bc]]’。2)list2str([‘a’,[‘b’,[‘c’]]) 应该返回’[a[b[c]]]’。请注意，该函数的输出是一个字符串，而不是一个列表，因为它被引用。实现如下: 123function list2str(s)&#123; return JSON.stringify(s).replace(/[&quot;|’|,|\\“|\\”|\\，]/g,&quot;&quot;)&#125; 2:字符串到列表,与上述相反。例子:1)str2list(‘[abc]’)应该返回[abc]。2)str2list(‘[a[bc]’)应该返回 [‘a’[‘b’’c’]。实现如下: 123456789101112function str2list(s)&#123; var reg = /^[A-Za-z]/ var str = &quot;&quot; for(var i of s)&#123; if(reg.test(i))&#123; str += &quot;&#x27;&quot; + i + &quot;&#x27;&quot;+&#x27;,&#x27; &#125;else&#123; str += i &#125; &#125; return eval(str)&#125;","categories":[],"tags":[]},{"title":"Javascript字典优势","slug":"JavaScript字典优势","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2021/12/08/JavaScript字典优势/","link":"","permalink":"https://corn0124.cn/2021/12/08/JavaScript%E5%AD%97%E5%85%B8%E4%BC%98%E5%8A%BF/","excerpt":"","text":"字典优势:完整的函数isGreaterThan(dict1,dict2)将输入两个JavaScript中的对象，只有键和数值。该函数返回True当且仅当dict1是就所有的键而言，大于或等于dict2，并且它是严格的至少在一个键上大于dict2。例子:dict1={‘a’:1,b’:2} 和 dict2={‘a’:1,’b’:1}。在这种情况下，dict1对a等于dict2，但对b更大，因此，该函数应该返回 True。dict1={‘a’:1’b’:1}和 dict2={‘a’:1’b’:1}。在这种情况下，dict1和 dict2是等价的;因此，该函数应该返回False。dict1={‘a’:1b’:0}和dict2={‘a’:0’b:1}。在这种情况下，dict1相对于a大于dict2，但相对于a而言较低乙;因此，该函数应该返回False。两个字典/对象可能不一定具有相同的键。如果字典/对象没有另一个拥有的键，则前者就该键而言低于后者，无论该值是多少后者可能有。例子:dict1={‘a:1’b’:2c:-10}和dict2={a’:1b:1}。字典1就所有键而言都大于dict2;因此，该函数应该返回True。dict1=’a’:1’b’:1 和 dict2={c’:0}。在这种情况下，dict1不是大于dict2，因为dict1没有键c;因此函数应该返回 False。实现如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function isGreaterThan(dict1, dict2) &#123; Object.prototype.equals = function (obj) &#123; if (this == obj) return true; if (typeof (obj) == &quot;undefined&quot; || obj == null || typeof (obj) != &quot;object&quot;) return false; var length = 0; var length1 = 0; for (var ele in this) &#123; length++; &#125; for (var ele in obj) &#123; length1++; &#125; if (length != length1) return false; if (obj.constructor == this.constructor) &#123; for (var ele in this) &#123; if (typeof (this[ele]) == &quot;object&quot;) &#123; if (!this[ele].equals(obj[ele])) return false; &#125; else if (typeof (this[ele]) == &quot;function&quot;) &#123; if (!this[ele].toString().equals(obj[ele].toString())) return false; &#125; else if (this[ele] != obj[ele]) return false; &#125; return true; &#125; return false; &#125;; if (dict1.equals(dict2)) &#123; return false &#125; else &#123; function isGreaterThan1() &#123; for (let item in dict2) &#123; if (dict1[item]) &#123; if (dict1[item] &lt; dict2[item]) &#123; return false &#125; else if (dict1[item] == dict2[item]) &#123; continue &#125; else &#123; continue &#125; &#125; else &#123; return false &#125; &#125; &#125; if (isGreaterThan1() == undefined) &#123; return true &#125; else if (isGreaterThan1() == false) &#123; return false &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"vue各种组件","slug":"vue各种组件","date":"un22fin22","updated":"un11fin11","comments":true,"path":"2021/11/30/vue各种组件/","link":"","permalink":"https://corn0124.cn/2021/11/30/vue%E5%90%84%E7%A7%8D%E7%BB%84%E4%BB%B6/","excerpt":"","text":"vue作为当下前端主流开发框架之一，也是前端初学者必备的一个技能点，此处省略好多好多废话，我们直接上重点，点进去就知道了，包你满意。 通讯录组件该组件可以实现按姓名首字母定位，点击联系人拨打电话等功能，效果如下 Mail.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126&lt;template&gt; &lt;view id=&quot;list&quot;&gt; &lt;ul class=&quot;list_user&quot; ref=&quot;listUser&quot;&gt; &lt;li v-for=&quot;(item, index) in userData&quot; :key=&quot;index&quot;&gt; &lt;p&gt;&#123;&#123; item.index &#125;&#125;&lt;/p&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) in item.user&quot; :key=&quot;index&quot; @click.stop=&quot;addName(item.name)&quot;&gt; &#123;&#123; item.name &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul class=&quot;list_index&quot; ref=&quot;Po&quot; &gt; &lt;li v-for=&quot;(item, index) in userIndex&quot; :key=&quot;index&quot; @click=&quot;setScroll(item)&quot; &gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;Mail&quot;, data() &#123; return &#123;&#125;; &#125;, props: &#123; userData: &#123; type: Array, default: function () &#123; return []; &#125;, &#125;, &#125;, //计算属性 computed: &#123; userIndex: function () &#123; return this.filterIndex(this.userData); console.log(this.filterIndex()); &#125;, &#125;, //右侧导航数据的调取 methods: &#123; filterIndex(data) &#123; var result = []; for (var i = 0; i &lt; data.length; i++) &#123; if (data[i].index) &#123; result.push(data[i].index); &#125; &#125; return result; &#125;, //右侧导航的距离位置 diweiPo() &#123; var dw = this.$refs.Po.offsetHeight; this.$refs.Po.style.marginTop = -dw / 2 + &quot;px&quot;; &#125;, //设置点击位置的值 setScroll(ev) &#123; // alert(ev) // console.log(ev) var setzhi = this.$refs.listUser.getElementsByTagName(&quot;p&quot;); for (var i = 0; i &lt; setzhi.length; i++) &#123; if (setzhi[i].innerHTML == ev) &#123; document.body.scrollTop = setzhi[i].offsetTop;//移动端获取滚动条的位置 // document.documentElement.scrollTop = setzhi[i].offsetTop;//pc端获取滚动条的位置 &#125; &#125; &#125;, //点击姓名 addName(e)&#123; uni.navigateTo(&#123; url:&quot;/pages/volunteer/newTask/newTask?name=&quot;+e &#125;) console.log(e) &#125; &#125;, mounted() &#123; this.diweiPo(); // console.log(11111111) &#125;,&#125;;&lt;/script&gt;&lt;style scoped&gt;* &#123; padding: 0; margin: 0;&#125;li &#123; list-style-type: none;&#125;#list &#123; position: relative; top: 100rpx;&#125;#list .list_user p,#list .list_user ul &#123; padding: 0 20rpx;&#125;#list .list_user p &#123; height: 40rpx; background: #F6F7FA; line-height: 40rpx; font-size: 24rpx;&#125;#list .list_user ul li &#123; height: 80rpx; height: 80rpx; line-height: 80rpx; border-bottom:2rpx solid #E5E5E5 ; font-size: 28rpx;&#125;#list .list_index &#123; position: fixed; top: 50%; right: 40rpx; z-index: 999;&#125;#list .list_index li&#123; height: 40rpx;&#125;&lt;/style&gt; index.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143&lt;template&gt; &lt;view&gt; &lt;view class=&quot;top&quot;&gt; &lt;view class=&quot;search&quot;&gt; &lt;image src=&quot;../../../static/image/search.png&quot; mode=&quot;&quot;&gt;&lt;/image&gt; &lt;input type=&quot;text&quot; placeholder=&quot;搜索&quot;&gt; &lt;text @click=&quot;click()&quot;&gt;搜索&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;Mail :userData=&#x27;userData&#x27;&gt;&lt;/Mail&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;// import Tabar from &quot;@/components/gobalComponents/Tabar&quot;;import Mail from &quot;@/components/gobalComponents/Mail&quot;;export default &#123; // name: &quot;SearchTask&quot;, components: &#123; // Tabar, Mail &#125;, data() &#123; return &#123; title: &quot;通讯录&quot;, userData:[ &#123; &#x27;index&#x27;:&#x27;A&#x27;, &#x27;user&#x27;:[ &#123;&#x27;name&#x27;:&#x27;a1&#x27;,&#x27;tel&#x27;:&#x27;123456789&#x27;&#125;, &#123;&#x27;name&#x27;:&#x27;a2&#x27;,&#x27;tel&#x27;:&#x27;123456789&#x27;&#125;, &#123;&#x27;name&#x27;:&#x27;a3&#x27;,&#x27;tel&#x27;:&#x27;123456789&#x27;&#125;, ] &#125;, &#123; &#x27;index&#x27;:&#x27;B&#x27;, &#x27;user&#x27;:[ &#123;&#x27;name&#x27;:&#x27;b1&#x27;,&#x27;tel&#x27;:&#x27;123456789&#x27;&#125;, &#123;&#x27;name&#x27;:&#x27;b2&#x27;,&#x27;tel&#x27;:&#x27;123456789&#x27;&#125;, &#123;&#x27;name&#x27;:&#x27;b3&#x27;,&#x27;tel&#x27;:&#x27;123456789&#x27;&#125;, ] &#125;, &#123; &#x27;index&#x27;:&#x27;C&#x27;, &#x27;user&#x27;:[ &#123;&#x27;name&#x27;:&#x27;c1&#x27;,&#x27;tel&#x27;:&#x27;123456789&#x27;&#125;, &#123;&#x27;name&#x27;:&#x27;c2&#x27;,&#x27;tel&#x27;:&#x27;123456789&#x27;&#125;, &#123;&#x27;name&#x27;:&#x27;c3&#x27;,&#x27;tel&#x27;:&#x27;123456789&#x27;&#125;, ] &#125;, &#123; &#x27;index&#x27;:&#x27;D&#x27;, &#x27;user&#x27;:[ &#123;&#x27;name&#x27;:&#x27;d1&#x27;,&#x27;tel&#x27;:&#x27;123456789&#x27;&#125;, &#123;&#x27;name&#x27;:&#x27;d2&#x27;,&#x27;tel&#x27;:&#x27;123456789&#x27;&#125;, &#123;&#x27;name&#x27;:&#x27;d3&#x27;,&#x27;tel&#x27;:&#x27;123456789&#x27;&#125;, ] &#125;, &#123; &#x27;index&#x27;:&#x27;E&#x27;, &#x27;user&#x27;:[ &#123;&#x27;name&#x27;:&#x27;e1&#x27;,&#x27;tel&#x27;:&#x27;123456789&#x27;&#125;, &#123;&#x27;name&#x27;:&#x27;e2&#x27;,&#x27;tel&#x27;:&#x27;123456789&#x27;&#125;, &#123;&#x27;name&#x27;:&#x27;e3&#x27;,&#x27;tel&#x27;:&#x27;123456789&#x27;&#125;, ] &#125;, &#123; &#x27;index&#x27;:&#x27;F&#x27;, &#x27;user&#x27;:[ &#123;&#x27;name&#x27;:&#x27;f1&#x27;,&#x27;tel&#x27;:&#x27;123456789&#x27;&#125;, &#123;&#x27;name&#x27;:&#x27;f2&#x27;,&#x27;tel&#x27;:&#x27;123456789&#x27;&#125;, &#123;&#x27;name&#x27;:&#x27;f3&#x27;,&#x27;tel&#x27;:&#x27;123456789&#x27;&#125;, ] &#125;, ] &#125;; &#125;, methods: &#123; click()&#123; alert(111) &#125; &#125;, created()&#123; // alert(222) // ZWJSBridge.setTitle(&#123; title: &#x27;通讯录&#x27;&#125;) .then((result) =&gt; &#123; console.log(result); &#125;).catch((error) =&gt; &#123; console.log(error); &#125;); &#125;&#125;;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.top&#123; position: fixed; left: 0; right: 0; height: 100rpx; background: #fff; z-index: 99999999; box-shadow: 0rpx 0rpx 14rpx 0rpx rgba(51, 51, 51, 0.13);&#125; .search&#123; width: 672rpx; height: 52rpx; margin: 24rpx auto; // margin-top: 24rpx; background: #F6F7FA; border-radius: 26rpx; image&#123; display: inline-block; vertical-align: middle; width: 26rpx; height: 26rpx; margin-left: 15rpx; &#125; input&#123; display: inline-block; width: 400rpx; height: 48rpx; border: none; font-size: 24rpx; color: #999; margin-left: 20rpx; background: #F6F7FA; vertical-align: middle; line-height: 48rpx; &#125; text&#123; // display: inline-block; width: 104rpx; height: 52rpx; background: #FFB243; border-radius: 22rpx; font-size: 24rpx; font-family: PingFang SC; font-weight: 500; color: #FFFFFF; text-align: center; line-height: 52rpx; vertical-align: top; float: right; &#125; &#125;&lt;/style&gt; Layout布局组件三栏布局左右两栏固定宽度，中间自适应，懒得放图了，自行YY layout.vue——子组件 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div class=&quot;layout_content&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;slot name=&quot;left&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class=&quot;main&quot;&gt; &lt;slot name=&quot;main&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;slot name=&quot;right&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.layout_content&#123; display: flex; width: 100%; height: 100%; .left,.right&#123; flex: 0 0 auto; &#125; .main&#123; flex: 1 1 auto; &#125;&#125;&lt;/style&gt; test.vue——父组件 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;template&gt; &lt;div class=&quot;test_content&quot;&gt; &lt;Layout&gt; &lt;template #left&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;/template&gt; &lt;template #main&gt; &lt;div class=&quot;main&quot;&gt;&lt;/div&gt; &lt;/template&gt; &lt;template #right&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/template&gt; &lt;/Layout&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Layout from &quot;../components/layout.vue&quot;;export default &#123; components: &#123; Layout, &#125;,&#125;;&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.test_content&#123; width: 100%; height: 600px;&#125;.left,.right &#123; width: 200px; height: 100%; background: cadetblue;&#125;.main &#123; width: 100%; height: 100%; background: chocolate;&#125;&lt;/style&gt; 圣杯布局头部导航栏，底部footer区域，中间是三栏基本布局 layout.vue——子组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;div class=&quot;layout_content&quot;&gt; &lt;header&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;div class=&quot;left&quot;&gt; &lt;slot name=&quot;left&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class=&quot;main&quot;&gt; &lt;slot name=&quot;main&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;slot name=&quot;right&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;;&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;header,footer &#123; width: 100%; height: 100%;&#125;main &#123; display: flex; width: 100%; height: 100%; .left, .right &#123; flex: 0 0 auto; &#125; .main &#123; flex: 1 1 auto; &#125;&#125;&lt;/style&gt; test.vue——父组件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;template&gt; &lt;div class=&quot;test_content&quot;&gt; &lt;Layout&gt; &lt;template #header&gt; &lt;div class=&quot;header&quot;&gt;&lt;/div&gt; &lt;/template&gt; &lt;template #left&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;/template&gt; &lt;template #main&gt; &lt;div class=&quot;main&quot;&gt;&lt;/div&gt; &lt;/template&gt; &lt;template #right&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/template&gt; &lt;template #footer&gt; &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt; &lt;/template&gt; &lt;/Layout&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Layout from &quot;../components/layout.vue&quot;;export default &#123; components: &#123; Layout, &#125;,&#125;;&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.test_content &#123; width: 100%; height: 100%;&#125;.header,.footer &#123; height: 50px; width: 100%; background: cyan;&#125;.left,.right &#123; width: 200px; height: 600px; background: cadetblue;&#125;.main &#123; width: 100%; height: 100%; background: chocolate;&#125;&lt;/style&gt; 组件递归——实现目录结构当我们不知道后端的大兄弟返给我们的数据有多少个层级时，可以考虑使用组件的递归，render渲染后面介绍。test.vue——父组件 123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt; &lt;Catalogue :list=&quot;list&quot; @select=&quot;seletClick&quot;&gt;&lt;/Catalogue&gt;&lt;/template&gt;&lt;script&gt;import Catalogue from &quot;../components/Catalogue.vue&quot;;export default &#123; components: &#123; Catalogue, &#125;, data()&#123; return&#123; list:[ &#123;name:&#x27;a&#x27;,isSelect:false&#125;, &#123;name:&#x27;b&#x27;,isSelect:false&#125;, &#123;name:&#x27;c&#x27;,isSelect:false,children:[ &#123;name:&#x27;c-1&#x27;,isSelect:false&#125;, &#123;name:&#x27;c-2&#x27;,isSelect:false&#125;, &#123;name:&#x27;c-3&#x27;,isSelect:false,children:[ &#123;name:&#x27;c-3-1&#x27;,isSelect:false&#125;, &#123;name:&#x27;c-3-2&#x27;,isSelect:false&#125;, &#123;name:&#x27;c-3-3&#x27;,isSelect:false&#125;, ]&#125;, ]&#125;, &#123;name:&#x27;d&#x27;,isSelect:false&#125;, ] &#125; &#125;, methods:&#123; seletClick(e)&#123; console.log(e) &#125; &#125;&#125;;&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;&lt;/style&gt; Catalogue.vue——子组件 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;ul&gt; &lt;li v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot; :class=&quot;&#123;active:item.isActive&#125;&quot; @click=&quot;handleClick(item)&quot;&gt; &#123;&#123;item.name&#125;&#125; &lt;Catalogue :list=&quot;item.children&quot; @click=&quot;handleClick(item)&quot;&gt;&lt;/Catalogue&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:&#x27;Catalogue&#x27;, props:&#123; list:&#123; type:Array, default:()=&gt;[] &#125; &#125;, methods:&#123; handleClick(item)&#123; this.$emit(&#x27;select&#x27;,item) &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;","categories":[],"tags":[]},{"title":"白嫖,还得是你","slug":"白嫖-还得是你","date":"un00fin00","updated":"un22fin22","comments":true,"path":"2021/11/28/白嫖-还得是你/","link":"","permalink":"https://corn0124.cn/2021/11/28/%E7%99%BD%E5%AB%96-%E8%BF%98%E5%BE%97%E6%98%AF%E4%BD%A0/","excerpt":"","text":"作为一名初级前端(bug)开发攻城狮,有什么是比白嫖更快乐的呢?除了饺子…不知道为什么最近总对饺子蛮感兴趣的…..曹贼,我给你们准备了一些开发过程中比较常见的js函数块,碰见了直接嫖就行了。 函数的节流与防抖节流1234567891011121314151617181920212223242526/** * 函数节流 规定时间内多次触发只执行一次 */function throttle(fn,delay)&#123; var lastTime; var timer; var delay = delay || 200; return function() &#123; var args = arguments; // 记录当前函数触发的时间 var nowTime = Date.now(); if (lastTime &amp;&amp; nowTime - lastTime &lt; delay) &#123; clearTimeout(timer); timer = setTimeout(function () &#123; // 记录上一次函数触发的时间 lastTime = nowTime; // 修正this指向问题 fn.apply(this, args); &#125;, delay); &#125;else&#123; lastTime = nowTime; fn.apply(this, args); &#125; &#125;&#125; 防抖1234567891011121314151617/** * 函数防抖 规定时间内结束后在触发，若在此时间内多次触发则重新计时 */function debounce(fn, delay) &#123; // 记录上一次的延时器 var timer = null; var delay = delay || 200; return function() &#123; var args = arguments; var that = this; // 清除上一次延时器 clearTimeout(timer) timer = setTimeout(function() &#123; fn.apply(that,args) &#125;, delay); &#125;&#125; 脱敏函数-用户隐私保护姓名脱敏12345678910111213function nameProtect(str) &#123; if (null != str &amp;&amp; str != undefined) &#123; if (str.length &lt;= 3) &#123; return &quot;*&quot; + str.substring(1, str.length); &#125; else if (str.length &gt; 3 &amp;&amp; str.length &lt;= 6) &#123; return &quot;**&quot; + str.substring(2, str.length); &#125; else if (str.length &gt; 6) &#123; return str.substring(0, 2) + &quot;****&quot; + str.substring(6, str.length); &#125; &#125; else &#123; return &quot;&quot;; &#125; &#125; 身份证脱敏123456function idCardProtect(value, row, index) &#123; var len = value.length; var xx = value.substring(1, len - 1); var values = value.replace(xx, &quot;****************&quot;); return values; &#125; 手机号脱敏123456function mobileProtect(value, row, index) &#123; var len = value.length; var xx = value.substring(3, len - 4); var values = value.replace(xx, &quot;****&quot;); return values; &#125; 时间篇根据秒数算展示时间1234567891011function setNumer(times) &#123; var h = Math.floor(times/3600); var m = Math.floor(times%3600/60); var s = Math.floor(times%60); //转换格式 h = h&gt;9?h:&quot;0&quot;+h; m = m&gt;9?m:&quot;0&quot;+m; s = s&gt;9?s:&quot;0&quot;+s; //在页面上显示 return &#123;h:h,m:m,s:s&#125;;&#125; 根据两个时间差毫秒数计算相差几天1234567891011121314151617181920212223242526function diffTime(times) &#123; //根据两个时间差毫秒数计算相差几天 var timediff = times; // var weeks = Math.floor(timediff / (1000 * 60 * 60 * 24 * 7)); // timediff -= weeks * (1000 * 60 * 60 * 24 * 7); var days = Math.floor(timediff / (1000 * 60 * 60 * 24)); timediff -= days * (1000 * 60 * 60 * 24); var hours = Math.floor(timediff / (1000 * 60 * 60)); timediff -= hours * (1000 * 60 * 60); var mins = Math.floor(timediff / (1000 * 60)); timediff -= mins * (1000 * 60); var secs = Math.floor(timediff / 1000); timediff -= secs * 1000; // console.log(days + &quot; 天, &quot; + hours + &quot; 小时, &quot; + mins + &quot; 分&quot;+secs+&quot;秒&quot;); var time_diff = &#123; // weeks : weeks, days: days, hours: hours, mins: mins, secs: secs &#125; return time_diff;&#125; 获得当前时间123456789101112131415function getNowTime(type)&#123; var date = new Date(); var year = date.getFullYear(); var month= date.getMonth()+1; var day = date.getDate(); month = month&gt;9?month:&quot;0&quot;+month; day = day&gt;9?day:&quot;0&quot;+day; var str; if(type==1)&#123; str = year+&quot;年&quot;+month+&quot;月&quot;+day+&quot;日&quot; &#125;else&#123; str = year+&quot;-&quot;+month+&quot;-&quot;+day &#125; return str&#125; 获得当前时间123456789101112131415function getNowTime(type)&#123; var date = new Date(); var year = date.getFullYear(); var month= date.getMonth()+1; var day = date.getDate(); month = month&gt;9?month:&quot;0&quot;+month; day = day&gt;9?day:&quot;0&quot;+day; var str; if(type==1)&#123; str = year+&quot;年&quot;+month+&quot;月&quot;+day+&quot;日&quot; &#125;else&#123; str = year+&quot;-&quot;+month+&quot;-&quot;+day &#125; return str&#125; 判断当前(指定)时间是否在条件范围内12345678910var curDate = Date.parse(&#x27;2020-12-18&#x27;) //指定时间# var curDate = Date.parse(new Date()) //当前时间var beginDate = Date.parse(new Date(&#x27;2020-12-12&#x27;)) var endDate = new Date(&#x27;2020-12-25&#x27;)endDate = endDate.setDate(endDate.getDate()+1) //时间戳判断需要加一天(用于不知道截至时间)if(curDate &gt;= beginDate &amp;&amp; curDate &lt; endDate)&#123; console.log(&#x27;处于当前时间范围内&#x27;) &#125;else&#123; console.log(&#x27;不在当前时间范围内&#x27;) &#125; 数组篇普通数组去重12345678910function arryClear(arr)&#123; var tmp = new Array(); for(var i in arr)&#123; if(tmp.indexOf(arr[i])==-1)&#123; tmp.push(arr[i]); &#125; &#125; return tmp;&#125; 数组对象去重复参数说明:arry数组,Object根据的对象名 1234567891011function arryClearObj(arry,Object)&#123; var result = []; var obj = &#123;&#125;; for(var j=0;j&lt;arry.length;j++)&#123; if(!obj[arry[j][Object]])&#123; result.push(arry[j]); obj[arry[j][Object]] = true; &#125; &#125; return result;&#125; 表单验证验证手机号码1234567891011function checkPhone(num)&#123; const zz = /^1[3456789]\\d&#123;9&#125;$/; if(!zz.test(num))&#123; uni.showToast(&#123; title : &quot;请输入正确的手机号码&quot;, icon : &quot;none&quot; &#125;); return false &#125; return true;&#125; 邮箱验证1234567891011function checkEmail(num)&#123; const zz = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]&#123;2,3&#125;)&#123;1,2&#125;)$/; if(!zz.test(num))&#123; uni.showToast(&#123; title : &quot;邮箱格式不正确&quot;, icon : &quot;none&quot; &#125;); return false &#125; return true;&#125; 内存字节转换1234567891011121314151617181920function conver(limit)&#123; var size = &quot;&quot;; if( limit &lt; 0.1 * 1024 )&#123; //如果小于0.1KB转化成B size = limit.toFixed(2) + &quot;B&quot;; &#125;else if(limit &lt; 0.1 * 1024 * 1024 )&#123;//如果小于0.1MB转化成KB size = (limit / 1024).toFixed(2) + &quot;KB&quot;; &#125;else if(limit &lt; 0.1 * 1024 * 1024 * 1024 * 1024)&#123; //如果小于0.1GB转化成MB // size = (limit / (1024 * 1024)).toFixed(2) + &quot;MB&quot;; size = (limit / (1024 * 1024)).toFixed(2); &#125;else&#123; //其他转化成GB size = (limit / (1024 * 1024 * 1024)).toFixed(2) + &quot;GB&quot;; &#125; var sizestr = size + &quot;&quot;; var len = sizestr.indexOf(&quot;\\.&quot;); var dec = sizestr.substr(len + 1, 2); if(dec == &quot;00&quot;)&#123;//当小数点后为00时 去掉小数部分 return sizestr.substring(0,len) + sizestr.substr(len + 3,2); &#125; return sizestr; &#125; 随机生成字符串好奇这种需求是怎么来的,讲道理哦,不应该是后端小伙伴做的吗,像这种涉及到随机字符串生成的东西… 123456789var str = [&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;,&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;,&#x27;G&#x27;,&#x27;H&#x27;,&#x27;I&#x27;,&#x27;J&#x27;,&#x27;K&#x27;,&#x27;L&#x27;,&#x27;M&#x27;,&#x27;N&#x27;,&#x27;O&#x27;,&#x27;P&#x27;,&#x27;Q&#x27;,&#x27;R&#x27;,&#x27;S&#x27;,&#x27;T&#x27;,&#x27;U&#x27;,&#x27;V&#x27;,&#x27;W&#x27;,&#x27;X&#x27;,&#x27;Y&#x27;,&#x27;Z&#x27;];function generateMixed(n) &#123; var res = &quot;&quot;; for(var i = 0; i &lt; n ; i ++) &#123; var id = Math.ceil(Math.random()*35); res += str[id]; &#125; return res;&#125;","categories":[],"tags":[]},{"title":"前端碎片化","slug":"碎片化知识点","date":"un22fin22","updated":"un22fin22","comments":true,"path":"2021/11/23/碎片化知识点/","link":"","permalink":"https://corn0124.cn/2021/11/23/%E7%A2%8E%E7%89%87%E5%8C%96%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"受前端老学姐的影响,很早就想写写东西记录下日常的bug,但始终没有迈开那关键的一步,这个是她的 博客，感兴趣的小伙伴可以收藏一下,话不多说,下面就是我在日常工作中整理了一下基本(沙比)需求的解决办法。 微信小程序系列小程序打开pdf文件并重命名小程序开发中甲方需要插入一份pdf文件,正常的流程是将源文件通过上传文件接口上传至服务器后，前端拿到其返回的url链接,通过微信Api打开下载这个链接即可,可是问题来了,正常打开后该文件的文件名为32位字符串？这显然不符合甲方霸霸那独特且刁钻的口味,没办法,改呗,视图如下: 1234567891011121314151617181920212223242526wx.downloadFile(&#123;//亲测有效,非常银杏化 url: &#x27;https://oss-cn-hangzhou-zwynet-d01-a.internet.cloud.zj.gov.cn/zjty-oss/zjsport_filehost/2021-10-18/2a32dd2778a44e32abf8ad9d5b9186f4-file.pdf&#x27;, //接口pdf路径 success(val) &#123; const Path = val.tempFilePath; const fs = wx.getFileSystemManager(); fs.saveFile(&#123; tempFilePath: Path, //Path我这里是wx.downloadFile()下载下来的文件临时地址 //wx.env.USER_DATA_PATH这个是微信文件的路径 没试过别的 别的路径一般没有权限 filePath: wx.env.USER_DATA_PATH + &#x27;/&#x27; + &#x27;浙体产业宣传册&#x27; + &#x27;.pdf&#x27;, success: function(res) &#123; wx.openDocument(&#123; filePath: res.savedFilePath, showMenu: true, //分享的按钮 fileType: &#x27;pdf&#x27;, success: function(res) &#123; //现在再分享给别人的话 就有后缀了 console.log(&#x27;打开成功&#x27;); &#125; &#125;) &#125;, fail: function(res) &#123; console.log(res) &#125; &#125;) &#125; &#125;) 微信分享app12345678910111213141516171819202122232425262728293031323334353637383940414243444546const httpUrl = &quot;https://www.zjlanghun.com/logo.png&quot;; //分享缩略图function goShare(obj)&#123; console.log(&quot;obj: &quot; + JSON.stringify(obj)); uni.showActionSheet(&#123; itemList: [&#x27;微信好友&#x27;, &#x27;分享到朋友圈&#x27;], success: function (res) &#123; if(res.tapIndex==0)&#123; //微信好友 uni.share(&#123; provider: &quot;weixin&quot;, scene: &quot;WXSceneSession&quot;, type: 0, href: obj.href, title: obj.title, summary: obj.intro, imageUrl: httpUrl, success: function (res) &#123; // console.log(&quot;success:&quot; + JSON.stringify(res)); &#125;, fail: function (err) &#123; // console.log(&quot;fail:&quot; + JSON.stringify(err)); &#125; &#125;); &#125;else&#123; //分享到朋友圈 uni.share(&#123; provider: &quot;weixin&quot;, scene: &quot;WXSenceTimeline&quot;, type: 0, href: obj.href, title: obj.title, summary: obj.intro, imageUrl: httpUrl, success: function (res) &#123; // console.log(&quot;success:&quot; + JSON.stringify(res)); &#125;, fail: function (err) &#123; // console.log(&quot;fail:&quot; + JSON.stringify(err)); &#125; &#125;); &#125; &#125;, fail: function (res) &#123; // console.log(res.errMsg); &#125; &#125;);&#125; 移动端-浙里办应用开发引入高德地图JSapi并实现周边搜索功能由于是在浙里办App里面开发,所以我用的浙里办定位的api,喜欢的话可以也可使用高德自身的定位,懒得放图了,直接上代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;template&gt; &lt;view&gt; &lt;view class=&quot;map&quot; id=&quot;map&quot;&gt;&lt;/view&gt; &lt;view id=&quot;panel&quot;&gt;&lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; latitude: &#x27;&#x27;, longitude: &#x27;&#x27;, type:&#x27;&#x27; &#125; &#125;, onLoad(option) &#123; console.log(option.type) this.type = option.type //上个页面传过来的搜索类型 例如&#x27;酒店&#x27; console.log(&#x27;我先执行&#x27;) &#125;, mounted() &#123; console.log(&#x27;我后执行&#x27;) this.creatMap() &#125;, methods: &#123; //获取当前位置信息 async getMyLocation() &#123; console.log(111111) await ZWJSBridge.getLocation().then((result) =&gt; &#123; console.log(result.latitude); this.latitude = result.latitude this.longitude = result.longitude &#125;).catch((error) =&gt; &#123; console.log(error); &#125;); &#125;, async creatMap()&#123; try&#123; await this.getMyLocation() var that = this var marker, map = new AMap.Map(&quot;map&quot;, &#123; resizeEnable: true, zoom: 15, center: [that.longitude, that.latitude] &#125;); marker = new AMap.Marker(&#123; icon: &quot;//a.amap.com/jsapi_demos/static/demo-center/icons/poi-marker-default.png&quot;, position: [that.longitude, that.latitude], offset: new AMap.Pixel(-13, -30) &#125;); marker.setMap(map); AMap.service([&quot;AMap.PlaceSearch&quot;], function() &#123; //构造地点查询类 var placeSearch = new AMap.PlaceSearch(&#123; // type: &#x27;住宿&#x27;, // 兴趣点类别 pageSize: 3, // 单页显示结果条数 pageIndex: 1, // 页码 map: map, panel: &quot;panel&quot;, // 结果列表将在此容器中进行展示。 autoFitView: true // 是否自动调整地图视野使绘制的 Marker点都处于视口的可见范围 &#125;); placeSearch.searchNearBy(that.type, [that.longitude, that.latitude], 1000, function(status, result) &#123; console.log(status, result) &#125;); &#125;); &#125;catch(err)&#123; console.log(err) &#125; &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt; .map &#123; width: 100%; height: 100vh; &#125; #panel &#123; position: fixed; background-color: white; max-height: 90%; overflow-y: auto; bottom: 10rpx; width: 100%; &#125; /deep/.amap-icon img &#123; width: 50rpx; height: 60rpx; &#125;&lt;/style&gt; ps:记得引入高德的JsApi,高德demo演示 原生uniapp项目变成vue-cli工程,并指定build打包路径浙里办新平台项目单应用的部署发布需要vue-cli工程的项目,原因是新平台下发布项目会默认依次执行 npm i,npm run serve,npm run build,并且打包后的文件夹只能叫build,并且执行build文件夹下面根目录的index.html文件,下面将展示如何将uni项目套个vue-cli的壳并且修改默认的打包路径,如下:一、全局安装vue-cli 1npm install -g @vue/cli 二、创建一个空的uni-app工程,模板选择默认模板就好了 1vue create -p dcloudio/uni-preset-vue demo 三、安装sass 1234npm install node-sass@4.14.1 --savenpm install sass-loader@8.0.0 --save// 注：node-sass和sass-loader安装需要制定版本，版本太高会不兼容，指定版本如安装不成功自行百度解决办法 四、偷梁换柱 1将新项目中的src下面的文件全部删掉,将原来uni项目全部拷贝到src下面 五、将uni的less文件全部改成scss,包括vue页面lang=’less’替换为lang=’scss’六、修改build路径,根目录下package.json文件build-h5配置 123&quot;build:h5&quot;: &quot;cross-env NODE_ENV=production UNI_PLATFORM=h5 vue-cli-service uni-build&quot;替换为&quot;build:h5&quot;: &quot;cross-env NODE_ENV=production UNI_PLATFORM=h5 UNI_OUTPUT_DIR=build vue-cli-service uni-build&quot; 浙里办单应用二次回退问题解决当我们项目中存在获取用户信息的操作时,必然会用到浙里办的单点登录,就是用一个空白的首页里面存放单点登录的跳转链接,判断用户是否登录/实名认证,若已登录/实名认证,则重定向到我们项目初始着陆页面,按照这个思想逻辑来实现单点登录的话,难免会遇到用户端二次回退的问题(在项目着陆页面触发移动端的返回事件后会返回到我们的单点登录的空白页面,也有可能存在回退死循环,根本无法通过默认的回退事件回退到上一个页面),解决的办法也很简单,可以考虑在项目着陆页面加个浙里办的Api——关闭当前应用,如下: ZWJSBridge.close().then((result) =&gt; &#123; console.log(result); &#125;).catch((error) =&gt; &#123; console.log(error); &#125;); ps:此处需要监听移动端的默认返回事件,用这个api替换掉就行了 1234567891011121314methods:&#123; goBack()&#123; ZWJSBridge.close().then((result) =&gt; &#123; console.log(result); &#125;).catch((error) =&gt; &#123; console.log(error); &#125;); &#125;&#125;,mounted()&#123; if (window.history &amp;&amp; window.history.pushState) &#123; // 向历史记录中插入了当前页 history.pushState(null, null, document.URL); window.addEventListener(&#x27;popstate&#x27;, this.goBack, false);&#125;&#125;,destroyed()&#123; window.removeEventListener(&#x27;popstate&#x27;, this.goBack, false); &#125;, 浙里办法人+个人的单点登录判断有时候浙里办的应用需要支持法人和个人两种身份的登录，且登录后的着落页面相同，就好比一个表单，它既能让法人登录后去提交也支持个人登录后去提交，而不是两个分开的页面。登录判断如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243ZWJSBridge.onReady(() =&gt; &#123; // alert(1111111); console.log(&#x27;初始化完成后，执行bridge方法&#x27;) &#125;); console.log(window.location.href) ZWJSBridge.getUserType().then((result) =&gt; &#123; console.log(result.userType); if(result.userType == 2)&#123; if(window.location.href.indexOf(&#x27;userData&#x27;) == -1)&#123; window.location.replace( &#x27;https://esso.zjzwfw.gov.cn/opensso/spsaehandler/metaAlias/sp?spappurl=https://gl.tyj.zj.gov.cn/api-movement/map/api/user/corpLogin?goto=https://mapi.zjzwfw.gov.cn/web/mgop/gov-open/zj/2001943960/reserved/index.html1&#x27; ) var str = util.getQueryString(&quot;userData&quot;); //如果在浙里办实名认证过,就能拿到返回的信息 var temp = JSON.parse(str); uni.setStorageSync(&#x27;zuserId&#x27;, temp.uniscid); return &#125; &#125;else&#123; if(window.location.href.indexOf(&#x27;login&#x27;) == -1)&#123; window.location.replace( &#x27;https://puser.zjzwfw.gov.cn/sso/mobile.do?action=oauth&amp;scope=1&amp;servicecode=qmjsggfwyy&amp;goto=https://mapi.zjzwfw.gov.cn/web/mgop/gov-open/zj/2001943960/reserved/index.html&#x27; ) var str = util.getQueryString(&quot;user&quot;); //如果在浙里办实名认证过,就能拿到返回的信息 var temp = JSON.parse(str); uni.setStorageSync(&#x27;user&#x27;, temp); uni.setStorageSync(&#x27;apiToken&#x27;, temp.apiToken); uni.setStorageSync(&#x27;zuserId&#x27;, temp.userId); console.log(uni.getStorageSync(&#x27;zuserId&#x27;),88888) return &#125;else if(window.location.href.split(&#x27;=&#x27;)[1] === &quot;false#/&quot;)&#123; uni.showModal(&#123; content: &quot;请您完成实名制认证，谢谢&quot;, showCancel: false &#125;) return &#125; &#125; uni.reLaunch(&#123; url:&quot;./examine&quot; &#125;) &#125;).catch((error) =&gt; &#123; console.log(error); &#125;);","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"猫狗日记","slug":"猫狗日记","permalink":"https://corn0124.cn/tags/%E7%8C%AB%E7%8B%97%E6%97%A5%E8%AE%B0/"}]}